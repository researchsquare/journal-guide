upstream app {
    server app:3000;
}

server {
    listen 80 default_server;
    server_name _;
    root /site/public;

    # health check for LB / readiness probes
    location = /health {
        access_log off;
        return 200;
    }

    # serve next static assets directly
    location /_next/static/ {
        try_files $uri $uri/ =404;
    }

    # serve next image cache if used
    location /_next/image/ {
        try_files $uri $uri/ =404;
    }

    # custom error page for maintenance and other 5xx errors
    error_page 500 502 503 504 /brb.html;
    location = /brb.html {
        internal;
        try_files /brb.html =404;
    }

    # internal maintenance marker (no body, used to trigger 503)
    location = /maintenance.enable {
        internal;
        return 503;
    }

    # main app proxy with maintenance toggle using try_files (no `if`)
    location / {
        # if the file /site/public/maintenance.enable exists, nginx will internally
        # serve /maintenance.enable which returns 503 and triggers the error_page.
        try_files /maintenance.enable @proxy;
    }

    # actual proxy handler (used when not in maintenance)
    location @proxy {
        proxy_intercept_errors on;

        # preserve original request info for the app
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        # support websockets / http1.1 upgrades
        proxy_http_version 1.1;
        proxy_set_header Connection $http_connection;
        proxy_set_header Upgrade $http_upgrade;
        proxy_cache_bypass $http_upgrade;

        # timeouts (tune them to your app)
        proxy_connect_timeout 5s;
        proxy_send_timeout 60s;
        proxy_read_timeout 60s;

        proxy_pass http://app;
        proxy_redirect off;
    }
}
